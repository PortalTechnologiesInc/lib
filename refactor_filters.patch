diff --git a/src/app/auth.rs b/src/app/auth.rs
index 2c50ca6..f1b7f3c 100644
--- a/src/app/auth.rs
+++ b/src/app/auth.rs
@@ -18,6 +18,7 @@ use crate::{
     router::{
         ConversationError, MultiKeyListener, MultiKeyListenerAdapter, Response,
         adapters::{ConversationWithNotification, one_shot::OneShotSender},
+        conversation::{ConversationFilter, FilterType},
     },
 };
 
@@ -89,14 +90,16 @@ impl MultiKeyListener for AuthChallengeListenerConversation {
     type Message = AuthChallengeContent;
 
     fn init(state: &crate::router::MultiKeyListenerAdapter<Self>) -> Result<Response, Self::Error> {
-        let mut filter = Filter::new()
-            .kinds(vec![Kind::from(AUTH_CHALLENGE)])
-            .pubkey(state.local_key);
-
-        if let Some(subkey_proof) = &state.subkey_proof {
-            filter = filter.pubkey(subkey_proof.main_key.into());
-        }
-
+        let filter = ConversationFilter::new(FilterType::DirectMessage {
+            kinds: vec![AUTH_CHALLENGE, AUTH_RESPONSE],
+            pubkey: state.local_key,
+            authors: None,
+            proof_key: if let Some(subkey_proof) = &state.subkey_proof {
+                Some(subkey_proof.main_key.into())
+            } else {
+                None
+            },
+        });
         Ok(Response::new().filter(filter))
     }
 
diff --git a/src/app/payments.rs b/src/app/payments.rs
index 2583dc3..3fd39ab 100644
--- a/src/app/payments.rs
+++ b/src/app/payments.rs
@@ -23,6 +23,7 @@ use crate::{
     router::{
         ConversationError, MultiKeyListener, MultiKeyListenerAdapter, Response,
         adapters::{ConversationWithNotification, one_shot::OneShotSender},
+        conversation::{ConversationFilter, FilterType},
     },
 };
 
@@ -43,16 +44,16 @@ impl MultiKeyListener for PaymentRequestListenerConversation {
     type Message = PaymentRequestContent;
 
     fn init(state: &crate::router::MultiKeyListenerAdapter<Self>) -> Result<Response, Self::Error> {
-        let mut filter = Filter::new()
-            .kinds(vec![
-                Kind::Custom(PAYMENT_REQUEST),
-                Kind::Custom(RECURRING_PAYMENT_REQUEST),
-            ])
-            .pubkey(state.local_key);
-
-        if let Some(subkey_proof) = &state.subkey_proof {
-            filter = filter.pubkey(subkey_proof.main_key.into());
-        }
+        let filter = ConversationFilter::new(FilterType::DirectMessage {
+            kinds: vec![PAYMENT_REQUEST, RECURRING_PAYMENT_REQUEST],
+            pubkey: state.local_key,
+            authors: None,
+            proof_key: if let Some(subkey_proof) = &state.subkey_proof {
+                Some(subkey_proof.main_key.into())
+            } else {
+                None
+            },
+        });
 
         Ok(Response::new().filter(filter))
     }
diff --git a/src/close_subscription.rs b/src/close_subscription.rs
index c380a83..1de03a1 100644
--- a/src/close_subscription.rs
+++ b/src/close_subscription.rs
@@ -14,6 +14,7 @@ use crate::{
     router::{
         ConversationError, MultiKeyListener, MultiKeyListenerAdapter, MultiKeySender, Response,
         adapters::{ConversationWithNotification, one_shot::OneShotSender},
+        conversation::{ConversationFilter, FilterType},
     },
 };
 
@@ -35,10 +36,10 @@ impl MultiKeySender for CloseRecurringPaymentConversation {
 
     fn get_filter(
         _state: &crate::router::MultiKeySenderAdapter<Self>,
-    ) -> Result<Filter, Self::Error> {
+    ) -> Result<ConversationFilter, Self::Error> {
         // Empty filter that will not match any events
         // TODO: we should avoid subscribing to relays for empty filters
-        Ok(Filter::new().id(EventId::all_zeros()))
+        Ok(ConversationFilter::new(FilterType::Empty))
     }
 
     fn build_initial_message(
@@ -96,14 +97,12 @@ impl MultiKeyListener for CloseRecurringPaymentReceiverConversation {
     type Message = CloseRecurringPaymentContent;
 
     fn init(state: &crate::router::MultiKeyListenerAdapter<Self>) -> Result<Response, Self::Error> {
-        let mut filter = Filter::new()
-            .kinds(vec![Kind::from(RECURRING_PAYMENT_CANCEL)])
-            //.pubkey(state.user.ok_or(ConversationError::UserNotSet)?);
-            .pubkey(state.local_key);
-
-        if let Some(subkey_proof) = &state.subkey_proof {
-            filter = filter.pubkey(subkey_proof.main_key.into());
-        }
+        let filter = ConversationFilter::new(FilterType::DirectMessage {
+            kinds: vec![RECURRING_PAYMENT_CANCEL],
+            pubkey: state.local_key,
+            authors: None,
+            proof_key: state.subkey_proof.as_ref().map(|p| p.main_key.into()),
+        });
 
         Ok(Response::new().filter(filter))
     }
diff --git a/src/invoice.rs b/src/invoice.rs
index 1d94328..b9be4a0 100644
--- a/src/invoice.rs
+++ b/src/invoice.rs
@@ -20,6 +20,7 @@ use crate::{
         ConversationError, MultiKeyListener, MultiKeyListenerAdapter, MultiKeySender,
         MultiKeySenderAdapter, Response,
         adapters::{ConversationWithNotification, one_shot::OneShotSender},
+        conversation::{ConversationFilter, FilterType},
     },
 };
 
@@ -39,16 +40,20 @@ impl MultiKeySender for InvoiceRequestConversation {
 
     fn get_filter(
         state: &crate::router::MultiKeySenderAdapter<Self>,
-    ) -> Result<Filter, Self::Error> {
-        let mut filter = Filter::new()
-            .kinds(vec![Kind::Custom(INVOICE_RESPONSE)])
-            .authors(state.subkeys.iter().chain([&state.user]).cloned())
-            .pubkey(state.local_key);
-
-        if let Some(subkey_proof) = &state.subkey_proof {
-            filter = filter.pubkey(subkey_proof.main_key.into());
-        }
-
+    ) -> Result<ConversationFilter, Self::Error> {
+        let filter = ConversationFilter::new(FilterType::DirectMessage {
+            kinds: vec![INVOICE_RESPONSE],
+            pubkey: state.local_key,
+            authors: Some(
+                state
+                    .subkeys
+                    .iter()
+                    .chain([&state.user])
+                    .map(|k| *k)
+                    .collect(),
+            ),
+            proof_key: state.subkey_proof.as_ref().map(|p| p.main_key.into()),
+        });
         Ok(filter)
     }
 
@@ -110,13 +115,12 @@ impl MultiKeyListener for InvoiceReceiverConversation {
     type Message = InvoiceRequestContent;
 
     fn init(state: &crate::router::MultiKeyListenerAdapter<Self>) -> Result<Response, Self::Error> {
-        let mut filter = Filter::new()
-            .kinds(vec![Kind::Custom(INVOICE_REQUEST)])
-            .pubkey(state.local_key);
-
-        if let Some(subkey_proof) = &state.subkey_proof {
-            filter = filter.pubkey(subkey_proof.main_key.into());
-        }
+        let filter = ConversationFilter::new(FilterType::DirectMessage {
+            kinds: vec![INVOICE_REQUEST],
+            pubkey: state.local_key,
+            authors: None,
+            proof_key: state.subkey_proof.as_ref().map(|p| p.main_key.into()),
+        });
 
         Ok(Response::new().filter(filter))
     }
diff --git a/src/profile.rs b/src/profile.rs
index b9a8954..e9b9add 100644
--- a/src/profile.rs
+++ b/src/profile.rs
@@ -5,6 +5,7 @@ use crate::{
     router::{
         Conversation, ConversationError, ConversationMessage, Response,
         adapters::{ConversationWithNotification, one_shot::OneShotSender},
+        conversation::ConversationFilter,
     },
 };
 
@@ -24,12 +25,14 @@ impl FetchProfileInfoConversation {
 
 impl Conversation for FetchProfileInfoConversation {
     fn init(&mut self) -> Result<crate::router::Response, crate::router::ConversationError> {
-        Ok(Response::new().filter(
+        let filter = ConversationFilter::new(crate::router::conversation::FilterType::Custom(
             Filter::new()
                 .author(self.pubkey)
                 .kind(Kind::Metadata)
                 .limit(1),
-        ))
+        ));
+
+        Ok(Response::new().filter(filter))
     }
 
     fn on_message(
diff --git a/src/router/adapters/multi_key_sender.rs b/src/router/adapters/multi_key_sender.rs
index 8ec43e0..0032238 100644
--- a/src/router/adapters/multi_key_sender.rs
+++ b/src/router/adapters/multi_key_sender.rs
@@ -8,7 +8,10 @@ use serde::de::DeserializeOwned;
 
 use nostr::{event::Kind, filter::Filter, key::PublicKey};
 
-use crate::protocol::model::{auth::SubkeyProof, event_kinds::SUBKEY_PROOF};
+use crate::{
+    protocol::model::{auth::SubkeyProof, event_kinds::SUBKEY_PROOF},
+    router::conversation::ConversationFilter,
+};
 
 use crate::router::{
     CleartextEvent, Conversation, ConversationError, ConversationMessage, Response,
@@ -22,7 +25,7 @@ pub trait MultiKeySender: Sized + Send + 'static {
     type Error: std::error::Error + Send + Sync + 'static;
     type Message: DeserializeOwned;
 
-    fn get_filter(_state: &MultiKeySenderAdapter<Self>) -> Result<Filter, Self::Error>;
+    fn get_filter(_state: &MultiKeySenderAdapter<Self>) -> Result<ConversationFilter, Self::Error>;
 
     fn build_initial_message(
         _state: &mut MultiKeySenderAdapter<Self>,
@@ -55,10 +58,10 @@ pub struct MultiKeySenderAdapter<Inner> {
 impl<T: MultiKeySender> Conversation for MultiKeySenderAdapter<T> {
     fn init(&mut self) -> Result<Response, ConversationError> {
         // Make a call to get the filter
-        let filter = <T as MultiKeySender>::get_filter(self)
+        let mut filter = <T as MultiKeySender>::get_filter(self)
             .map_err(|e| ConversationError::Inner(Box::new(e)))?;
         // Also listen for SUBKEY_PROOF messages
-        let filter = filter.kind(Kind::Custom(SUBKEY_PROOF));
+        let filter = filter.add_subkey_proof();
 
         // Then build the initial message, this will be sent to the user
         let mut response = <T as MultiKeySender>::build_initial_message(self, None)
@@ -129,10 +132,10 @@ impl<T: MultiKeySender> Conversation for MultiKeySenderAdapter<T> {
                     let mut response =
                         response_result.map_err(|e| ConversationError::Inner(Box::new(e)))?;
                     // Update the filter to reflect the new subkeys
-                    response.filter = <T as MultiKeySender>::get_filter(self)
+                    let filter = <T as MultiKeySender>::get_filter(self)
                         .map_err(|e| ConversationError::Inner(Box::new(e)))?;
                     // Add the SUBKEY_PROOF kind to the filter
-                    response.filter = response.filter.kinds(vec![Kind::Custom(SUBKEY_PROOF)]);
+                    response.filter = filter.add_subkey_proof();
 
                     Ok(response)
                 } else {
diff --git a/src/router/conversation.rs b/src/router/conversation.rs
index 0560d8f..ded28a9 100644
--- a/src/router/conversation.rs
+++ b/src/router/conversation.rs
@@ -1,9 +1,14 @@
 use std::{borrow::Borrow, fmt::Display, ops::Deref};
 
-use nostr::event::Event;
+use nostr::{
+    event::{Event, EventId, Kind},
+    filter::Filter,
+    key::PublicKey,
+};
 use serde::{Deserialize, Serialize};
 
 use crate::{
+    protocol::model::event_kinds::SUBKEY_PROOF,
     router::{CleartextEvent, Response},
     utils::random_string,
 };
@@ -78,3 +83,88 @@ pub enum ConversationError {
     #[error("Relay '{0}' is not connected")]
     RelayNotConnected(String),
 }
+
+// Filters for conversations
+#[derive(Clone, Debug, Default)]
+pub struct ConversationFilter {
+    filter_type: FilterType,
+    inner: Filter,
+}
+
+impl ConversationFilter {
+    pub fn new(filter_type: FilterType) -> ConversationFilter {
+        let filter = match &filter_type {
+            FilterType::DirectMessage {
+                kinds,
+                pubkey,
+                authors,
+                proof_key,
+            } => {
+                let mut filter = Filter::new()
+                    .kinds(kinds.into_iter().map(|f| Kind::Custom(*f)))
+                    .pubkey(pubkey.clone());
+                if let Some(authors) = authors {
+                    filter = filter.authors(authors.clone());
+                }
+                if let Some(proof_key) = proof_key {
+                    filter = filter.pubkey(proof_key.clone());
+                }
+                filter
+            }
+            FilterType::Empty => Filter::new().id(EventId::all_zeros()),
+            FilterType::Custom(filter) => filter.clone(),
+        };
+
+        ConversationFilter {
+            filter_type,
+            inner: filter,
+        }
+    }
+
+    pub fn could_be_joined(&self, other: &ConversationFilter) -> bool {
+        match (&self.filter_type, &other.filter_type) {
+            (
+                FilterType::DirectMessage { kinds, pubkey, .. },
+                FilterType::DirectMessage {
+                    kinds: other_kinds,
+                    pubkey: other_pubkey,
+                    ..
+                },
+            ) => {
+                pubkey == other_pubkey
+            },
+            (FilterType::Empty, FilterType::Empty) => true,
+            (FilterType::Custom(_), FilterType::Custom(_)) => false,
+            _ => false,
+        }
+    }
+
+    pub fn add_subkey_proof(mut self) -> Self {
+        self.inner = self.inner.kinds(vec![Kind::Custom(SUBKEY_PROOF)]);
+        self
+    }
+
+    pub fn as_nostr_filter(&self) -> &Filter {
+        &self.inner
+    }
+}
+
+#[derive(Clone, Debug)]
+pub enum FilterType {
+    DirectMessage {
+        kinds: Vec<u16>,
+        pubkey: PublicKey,
+        authors: Option<Vec<PublicKey>>,
+        proof_key: Option<PublicKey>,
+    },
+    Empty,
+
+    /// Internal, don't use this in conversations
+    Custom(Filter),
+}
+
+impl Default for FilterType {
+    fn default() -> Self {
+        Self::Custom(Filter::new())
+    }
+}
diff --git a/src/router/mod.rs b/src/router/mod.rs
index d6a17d6..ede2c50 100644
--- a/src/router/mod.rs
+++ b/src/router/mod.rs
@@ -19,7 +19,7 @@ use tokio::sync::{Mutex, RwLock, RwLockReadGuard, mpsc};
 
 use crate::{
     protocol::{LocalKeypair, model::event_kinds::SUBKEY_PROOF},
-    router::conversation::ConversationId,
+    router::conversation::{ConversationFilter, ConversationId, FilterType},
     utils::random_string,
 };
 
@@ -57,7 +57,7 @@ pub struct MessageRouter<C: Channel> {
     keypair: LocalKeypair,
     conversations: Mutex<HashMap<ConversationId, DynConversation>>,
     aliases: Mutex<HashMap<ConversationId, Vec<u64>>>,
-    filters: RwLock<HashMap<ConversationId, Filter>>,
+    filters: RwLock<HashMap<ConversationId, ConversationFilter>>,
     subscribers: Mutex<HashMap<ConversationId, Vec<mpsc::Sender<serde_json::Value>>>>,
     end_of_stored_events: Mutex<HashMap<String, usize>>,
 
@@ -110,7 +110,11 @@ where
                         &url
                     );
                     self.channel
-                        .subscribe_to(vec![url.clone()], conversation_id, filter.clone())
+                        .subscribe_to(
+                            vec![url.clone()],
+                            conversation_id,
+                            filter.as_nostr_filter().clone(),
+                        )
                         .await
                         .map_err(|e| ConversationError::Inner(Box::new(e)))?;
 
@@ -126,7 +130,11 @@ where
                         let alias = ConversationId::from_alias(conversation_id.as_str(), *alias);
                         if let Some(filter) = filters.get(&alias) {
                             self.channel
-                                .subscribe_to(vec![url.clone()], &alias, filter.clone())
+                                .subscribe_to(
+                                    vec![url.clone()],
+                                    &alias,
+                                    filter.as_nostr_filter().clone(),
+                                )
                                 .await
                                 .map_err(|e| ConversationError::Inner(Box::new(e)))?;
                         }
@@ -376,7 +384,7 @@ where
                 }
 
                 if let LocalEvent::Message(event) = &event {
-                    if filter.match_event(&event) {
+                    if filter.as_nostr_filter().match_event(&event) {
                         other_conversations.push(id.clone());
                     }
                 }
@@ -448,7 +456,9 @@ where
                 .await?
         };
 
-        if !response.filter.is_empty() {
+        if !response.filter.as_nostr_filter().is_empty() {
+            let nostr_filter = response.filter.as_nostr_filter().clone();
+
             self.filters
                 .write()
                 .await
@@ -459,7 +469,7 @@ where
 
                 log::trace!("Subscribing to relays = {:?}", selected_relays);
                 self.channel
-                    .subscribe_to(selected_relays, id, response.filter.clone())
+                    .subscribe_to(selected_relays, id, nostr_filter)
                     .await
                     .map_err(|e| ConversationError::Inner(Box::new(e)))?;
 
@@ -467,7 +477,7 @@ where
             } else {
                 log::trace!("Subscribing to all relays");
                 self.channel
-                    .subscribe(id, response.filter.clone())
+                    .subscribe(id, nostr_filter)
                     .await
                     .map_err(|e| ConversationError::Inner(Box::new(e)))?;
 
@@ -542,15 +552,14 @@ where
                 .or_default()
                 .push(alias_num);
 
-            let filter = Filter::new()
+            let nostr_filter = Filter::new()
                 .kinds(vec![Kind::Custom(SUBKEY_PROOF)])
                 .events(events_to_broadcast.iter().map(|e| e.id));
 
+            let filter = ConversationFilter::new(FilterType::Custom(nostr_filter.clone()));
+
             let alias = ConversationId::from_alias(id.as_str(), alias_num);
-            self.filters
-                .write()
-                .await
-                .insert(alias.clone(), filter.clone());
+            self.filters.write().await.insert(alias.clone(), filter);
 
             if let Some(selected_relays) = selected_relays_optional.clone() {
                 log::trace!(
@@ -558,7 +567,7 @@ where
                     selected_relays
                 );
                 self.channel
-                    .subscribe_to(selected_relays, &alias, filter)
+                    .subscribe_to(selected_relays, &alias, nostr_filter)
                     .await
                     .map_err(|e| ConversationError::Inner(Box::new(e)))?;
             } else {
@@ -566,7 +575,7 @@ where
                 // Subscribe to subkey proofs to all
 
                 self.channel
-                    .subscribe(&alias, filter)
+                    .subscribe(&alias, nostr_filter)
                     .await
                     .map_err(|e| ConversationError::Inner(Box::new(e)))?;
             }
@@ -795,7 +804,7 @@ struct ResponseEntry {
 /// ```
 #[derive(Debug, Default)]
 pub struct Response {
-    filter: Filter,
+    filter: ConversationFilter,
     responses: Vec<ResponseEntry>,
     notifications: Vec<serde_json::Value>,
     finished: bool,
@@ -814,7 +823,7 @@ impl Response {
     ///
     /// # Arguments
     /// * `filter` - The filter to set
-    pub fn filter(mut self, filter: Filter) -> Self {
+    pub fn filter(mut self, filter: ConversationFilter) -> Self {
         self.filter = filter;
         self
     }
@@ -997,3 +1006,7 @@ impl<T: Serialize> DerefMut for NotificationStream<T> {
         &mut self.stream
     }
 }
+
+//
+
+pub struct FilterMetadata {}
diff --git a/src/sdk/auth.rs b/src/sdk/auth.rs
index effbb4d..9224142 100644
--- a/src/sdk/auth.rs
+++ b/src/sdk/auth.rs
@@ -16,7 +16,9 @@ use crate::{
     },
     router::{
         ConversationError, MultiKeyListener, MultiKeyListenerAdapter, MultiKeySender,
-        MultiKeySenderAdapter, Response, adapters::ConversationWithNotification,
+        MultiKeySenderAdapter, Response,
+        adapters::ConversationWithNotification,
+        conversation::{ConversationFilter, FilterType},
     },
     utils::random_string,
 };
@@ -39,13 +41,16 @@ impl MultiKeyListener for KeyHandshakeReceiverConversation {
     type Message = KeyHandshakeContent;
 
     fn init(state: &crate::router::MultiKeyListenerAdapter<Self>) -> Result<Response, Self::Error> {
-        let mut filter = Filter::new()
-            .kinds(vec![Kind::from(KEY_HANDSHAKE)])
-            .pubkey(state.local_key);
-
-        if let Some(subkey_proof) = &state.subkey_proof {
-            filter = filter.pubkey(subkey_proof.main_key.into());
-        }
+        let filter = ConversationFilter::new(FilterType::DirectMessage {
+            kinds: vec![KEY_HANDSHAKE],
+            pubkey: state.local_key,
+            authors: None,
+            proof_key: if let Some(subkey_proof) = &state.subkey_proof {
+                Some(subkey_proof.main_key.into())
+            } else {
+                None
+            },
+        });
 
         Ok(Response::new().filter(filter))
     }
@@ -104,15 +109,24 @@ impl MultiKeySender for AuthChallengeSenderConversation {
 
     fn get_filter(
         state: &crate::router::MultiKeySenderAdapter<Self>,
-    ) -> Result<Filter, Self::Error> {
-        let mut filter = Filter::new()
-            .kinds(vec![Kind::from(AUTH_RESPONSE)])
-            .authors(state.subkeys.iter().chain([&state.user]).cloned())
-            .pubkey(state.local_key);
-
-        if let Some(subkey_proof) = &state.subkey_proof {
-            filter = filter.pubkey(subkey_proof.main_key.into());
-        }
+    ) -> Result<ConversationFilter, Self::Error> {
+        let filter = ConversationFilter::new(FilterType::DirectMessage {
+            kinds: vec![AUTH_RESPONSE],
+            pubkey: state.local_key,
+            authors: Some(
+                state
+                    .subkeys
+                    .iter()
+                    .chain([&state.user])
+                    .map(|k| *k)
+                    .collect(),
+            ),
+            proof_key: if let Some(subkey_proof) = &state.subkey_proof {
+                Some(subkey_proof.main_key.into())
+            } else {
+                None
+            },
+        });
 
         Ok(filter)
     }
diff --git a/src/sdk/payments.rs b/src/sdk/payments.rs
index 5f2f44f..10e54f4 100644
--- a/src/sdk/payments.rs
+++ b/src/sdk/payments.rs
@@ -11,6 +11,7 @@ use crate::{
     router::{
         ConversationError, MultiKeySender, MultiKeySenderAdapter, Response,
         adapters::ConversationWithNotification,
+        conversation::{ConversationFilter, FilterType},
     },
 };
 use nostr::{
@@ -48,15 +49,20 @@ impl MultiKeySender for RecurringPaymentRequestSenderConversation {
 
     fn get_filter(
         state: &crate::router::MultiKeySenderAdapter<Self>,
-    ) -> Result<Filter, Self::Error> {
-        let mut filter = Filter::new()
-            .kinds(vec![Kind::Custom(RECURRING_PAYMENT_RESPONSE)])
-            .authors(state.subkeys.iter().chain([&state.user]).cloned())
-            .pubkey(state.local_key);
-
-        if let Some(subkey_proof) = &state.subkey_proof {
-            filter = filter.pubkey(subkey_proof.main_key.into());
-        }
+    ) -> Result<ConversationFilter, Self::Error> {
+        let filter = ConversationFilter::new(FilterType::DirectMessage {
+            kinds: vec![RECURRING_PAYMENT_RESPONSE],
+            pubkey: state.local_key,
+            authors: Some(
+                state
+                    .subkeys
+                    .iter()
+                    .chain([&state.user])
+                    .map(|k| *k)
+                    .collect(),
+            ),
+            proof_key: state.subkey_proof.as_ref().map(|p| p.main_key.into()),
+        });
 
         Ok(filter)
     }
@@ -138,18 +144,20 @@ impl MultiKeySender for SinglePaymentRequestSenderConversation {
 
     fn get_filter(
         state: &crate::router::MultiKeySenderAdapter<Self>,
-    ) -> Result<Filter, Self::Error> {
-        let mut filter = Filter::new()
-            .kinds(vec![
-                Kind::Custom(PAYMENT_RESPONSE),
-                Kind::Custom(PAYMENT_CONFIRMATION),
-            ])
-            .authors(state.subkeys.iter().chain([&state.user]).cloned())
-            .pubkey(state.local_key);
-
-        if let Some(subkey_proof) = &state.subkey_proof {
-            filter = filter.pubkey(subkey_proof.main_key.into());
-        }
+    ) -> Result<ConversationFilter, Self::Error> {
+        let filter = ConversationFilter::new(FilterType::DirectMessage {
+            kinds: vec![PAYMENT_RESPONSE, PAYMENT_CONFIRMATION],
+            pubkey: state.local_key,
+            authors: Some(
+                state
+                    .subkeys
+                    .iter()
+                    .chain([&state.user])
+                    .map(|k| *k)
+                    .collect(),
+            ),
+            proof_key: state.subkey_proof.as_ref().map(|p| p.main_key.into()),
+        });
 
         Ok(filter)
     }
